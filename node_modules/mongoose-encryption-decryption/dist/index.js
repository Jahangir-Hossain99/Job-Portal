"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mongooseEncryptionDecryption = void 0;
const helper_1 = require("./helper");
const mongooseEncryptionDecryption = function (schema, options) {
    if (!options || !options.privateKey || !options.encodedFields) {
        throw new Error('Please provide the necessary options.');
    }
    const privateKey = helper_1.Helper.hashPrivateKey(options.privateKey);
    const encodedFields = options.encodedFields || [];
    function updatePreHook(_next) {
        var _a;
        const next = helper_1.Helper.getNextFunction(_next);
        const updateObj = {};
        for (const field of encodedFields) {
            const nestedFields = field.split('.');
            let nestedValue = this._update;
            for (let i = 0; i < nestedFields.length - 1; i++) {
                nestedValue = nestedValue === null || nestedValue === void 0 ? void 0 : nestedValue[nestedFields[i]];
            }
            if (nestedValue &&
                typeof nestedValue === 'object' &&
                nestedValue[nestedFields[nestedFields.length - 1]]) {
                const lastField = nestedFields[nestedFields.length - 1];
                const encryptedValue = helper_1.Helper.encrypt(nestedValue[lastField], privateKey);
                nestedValue[lastField] = encryptedValue;
            }
            else if ((_a = this._update) === null || _a === void 0 ? void 0 : _a[field]) {
                const encryptedData = helper_1.Helper.encrypt(this._update[field], privateKey);
                updateObj[field] = encryptedData;
            }
        }
        if (Object.keys(updateObj).length > 0) {
            this.updateOne(this.getQuery() || {}, updateObj);
        }
        next();
    }
    function postInitHook(_next, _data) {
        if (!this._conditions)
            return;
        const { next, data } = helper_1.Helper.getNextAndData(_next, _data);
        if (!data)
            return next();
        helper_1.Helper.decryptNestedFields(data, encodedFields, privateKey);
        next();
    }
    function preSaveHook(_next, documents) {
        const next = helper_1.Helper.getNextFunction(_next);
        const data = this;
        if (documents.length) {
            for (let i = 0, len = documents.length; i < len; i++) {
                helper_1.Helper.encryptNestedFields(documents[i], encodedFields, privateKey);
            }
        }
        else if (data) {
            helper_1.Helper.encryptNestedFields(data, encodedFields, privateKey);
        }
        next();
    }
    function postSaveHook(_next, _data) {
        const { next, data } = helper_1.Helper.getNextAndData(_next, _data);
        if (!data || (data === null || data === void 0 ? void 0 : data.isJestTestMock))
            return next();
        data.length
            ? helper_1.Helper.decryptArrayFields(data, encodedFields, privateKey)
            : helper_1.Helper.decryptNestedFields(data, encodedFields, privateKey);
        next();
    }
    function findHook(_next, _data) {
        const { next, data } = helper_1.Helper.getNextAndData(_next, _data);
        if (!data || data.length === 0)
            return next();
        helper_1.Helper.decryptArrayFields(data, encodedFields, privateKey);
        next();
    }
    function findOneHook(_next, _data) {
        const { next, data } = helper_1.Helper.getNextAndData(_next, _data);
        if (!data)
            return next();
        helper_1.Helper.decryptNestedFields(data, encodedFields, privateKey);
        next();
    }
    function updatePostHook(_next, _data) {
        var _a;
        const { next, data } = helper_1.Helper.getNextAndData(_next, _data);
        if (!data || (data === null || data === void 0 ? void 0 : data.isJestTestMock))
            return next();
        if (this._userProvidedFields || ((_a = this._mongooseOptions) === null || _a === void 0 ? void 0 : _a.lean)) {
            helper_1.Helper.decryptNestedFields(data, encodedFields, privateKey);
        }
        next();
    }
    function aggregateHook(_next, _data) {
        const { next, data } = helper_1.Helper.getNextAndData(_next, _data);
        if (!data)
            return next();
        helper_1.Helper.decryptArrayFields(data, encodedFields, privateKey);
        next();
    }
    schema.pre('save', preSaveHook);
    schema.pre('insertMany', preSaveHook);
    schema.pre('findOneAndUpdate', updatePreHook);
    schema.pre('updateOne', updatePreHook);
    schema.post('init', postInitHook);
    schema.post('save', postSaveHook);
    schema.post('insertMany', postSaveHook);
    schema.post('updateOne', updatePostHook);
    schema.post('find', findHook);
    schema.post(['findOne', 'findOneAndUpdate', 'findOneAndRemove', 'findOneAndDelete'], findOneHook);
    schema.post('aggregate', aggregateHook);
};
exports.mongooseEncryptionDecryption = mongooseEncryptionDecryption;
//# sourceMappingURL=index.js.map