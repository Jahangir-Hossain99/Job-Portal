"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Helper = void 0;
const crypto = require("crypto");
const config_1 = require("./config");
class Helper {
}
exports.Helper = Helper;
_a = Helper;
Helper.saltGenerator = () => crypto.randomBytes(16);
Helper.hashPrivateKey = (privateKey) => crypto
    .createHash(config_1.cryptoConfig.hashAlgorithm)
    .update(privateKey)
    .digest('hex')
    .substring(0, 32);
Helper.encrypt = function (plainTxt, secretKey) {
    try {
        const iv = Helper.saltGenerator();
        const cipher = crypto.createCipheriv(config_1.cryptoConfig.algorithm, secretKey, iv);
        const encrypted = cipher.update(plainTxt);
        const finalBuffer = Buffer.concat([encrypted, cipher.final()]);
        return (iv.toString('hex') +
            config_1.cryptoConfig.ivDividerSign +
            finalBuffer.toString('hex'));
    }
    catch (error) { }
};
Helper.encryptNestedFields = (data, fields, secretKey) => {
    try {
        for (const field of fields) {
            const nestedFields = field.split('.');
            let value = data;
            for (let i = 0; i < nestedFields.length - 1; i++) {
                value = value[nestedFields[i]];
            }
            if (value !== null && value !== void 0 ? value : '' !== '') {
                const lastField = nestedFields[nestedFields.length - 1];
                value[lastField] = _a.encrypt(value[lastField], secretKey);
            }
        }
    }
    catch (error) { }
};
Helper.decrypt = (encryptedTxt, secretKey) => {
    const [ivHex, encryptedDataHex] = encryptedTxt.split(config_1.cryptoConfig.ivDividerSign);
    if (!(ivHex !== null && ivHex !== void 0 ? ivHex : '' !== '') || !(encryptedDataHex !== null && encryptedDataHex !== void 0 ? encryptedDataHex : '' !== ''))
        return;
    const iv = Buffer.from(ivHex, 'hex');
    const encrypted = Buffer.from(encryptedDataHex, 'hex');
    const decipher = crypto.createDecipheriv(config_1.cryptoConfig.algorithm, secretKey, iv);
    const decrypted = decipher.update(encrypted);
    return Buffer.concat([decrypted, decipher.final()]).toString();
};
Helper.decryptNestedFields = (data, fields, secretKey) => {
    try {
        for (const field of fields) {
            const nestedFields = field.split('.');
            let value = data;
            let nestedValue = value;
            for (let i = 0; i < nestedFields.length - 1; i++) {
                value = value[nestedFields[i]];
                nestedValue = nestedValue[nestedFields[i]];
            }
            if ((value !== null && value !== void 0 ? value : '' !== '') &&
                value[nestedFields[nestedFields.length - 1]]) {
                const lastField = nestedFields[nestedFields.length - 1];
                value[lastField] = _a.decrypt(value[lastField], secretKey);
            }
        }
    }
    catch (error) { }
};
Helper.decryptArrayFields = (data, fields, secretKey) => {
    var _b;
    for (let i = 0, len = data.length; i < len; i++) {
        if (!((_b = data[i]) === null || _b === void 0 ? void 0 : _b.isJestTestMock)) {
            _a.decryptNestedFields(data[i], fields, secretKey);
        }
    }
};
Helper.getNextFunction = (next, data) => {
    switch (true) {
        case typeof next === 'function':
            return next;
        case typeof next === 'object' && typeof data === 'function':
            return data;
        default:
            return (error) => {
                if (error) {
                    throw error;
                }
            };
    }
};
Helper.getData = (next, data) => {
    if (!data || typeof next === 'object') {
        return next;
    }
    return data;
};
Helper.getNextAndData = (_next, _data) => {
    return {
        next: _a.getNextFunction(_next, _data),
        data: _a.getData(_next, _data),
    };
};
//# sourceMappingURL=helper.js.map